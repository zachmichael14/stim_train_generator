from dataclasses import dataclass
from typing import List, Tuple, Optional
import csv
from operator import attrgetter

@dataclass
class StimEvent:
    channel: int
    amplitude: float
    frequency: float
    duration: float
    start_time: float

    @property
    def end_time(self) -> float:
        """
        Calculate the end time of the stimulation event.
        Return:
            float: End time of the event
        """
        return self.start_time + self.duration

class StimDataManager:
    """
    This class manages the stimulation data by way of reading from and writing
    modifications to the stimuation CSV file. 

    Its data is plotted by the plotter widget and is generated by the
    front-end widgets.
    """
    def __init__(self):
        self.events: List[StimEvent] = []

    def load_from_csv(self, file_path: str) -> None:
        """
        Load stimulation events from a CSV file and create StimEvent objects.
        Add those newly created events to events list.
        Args:
            file_path (str): Path to the CSV file
        """
        with open(file_path, 'r') as f:
            reader = csv.reader(f)
            header = next(reader, None)  # Read the first row to skip as header
            current_time = 0
            for row in reader:
                channel = int(row[0])
                amplitude, frequency, duration = map(float, row[1:])
               
                event = StimEvent(
                    channel=channel,
                    amplitude=amplitude,
                    frequency=frequency,
                    duration=duration,
                    start_time=current_time
                )
                self.events.append(event)
                current_time += duration

    def add_event(self, event: StimEvent) -> None:
        """
        Add a new stimulation event and sort the events list.
        Args:
            event (StimEvent): Event to be added
        """
        self.events.append(event)
        self.sort_events()

    def remove_event(self, event: StimEvent) -> None:
        """
        Remove a stimulation event and recalculate the timeline.
        Args:
            event (StimEvent): Event to be removed
        """
        self.events.remove(event)
        self.recalculate_timeline()

    def modify_event(self, old_event: StimEvent, new_event: StimEvent) -> None:
        """
        Modify an existing event and recalculate the timeline.
        Args:
            old_event (StimEvent): Event to be replaced
            new_event (StimEvent): New event data
        """
        index = self.events.index(old_event)
        self.events[index] = new_event
        self.recalculate_timeline()

    def sort_events(self) -> None:
        """
        Sort the events list based on start time.
        """
        self.events.sort(key=attrgetter('start_time'))

    def recalculate_timeline(self) -> None:
        """
        Recalculate the timeline by sorting events and updating start times.
        """
        self.sort_events()
        current_time = 0
        for event in self.events:
            event.start_time = current_time
            current_time += event.duration

    def get_sorted_events(self) -> List[StimEvent]:
        """
        Get the list of sorted stimulation events.
        Return:
            List[StimEvent]: Sorted list of stimulation events
        """
        return self.events

    def get_events_for_channel(self, channel: int) -> List[StimEvent]:
        """
        Get all events for a specific channel.
        Args:
            channel (int): Channel number
        Return:
            List[StimEvent]: List of events for the specified channel
        """
        return [event for event in self.events if event.channel == channel]

    def get_time_range(self) -> Optional[Tuple[float, float]]:
        """
        Get the time range of all events.
        Return:
            Optional[Tuple[float, float]]: Start and end time of all events, or None if no events
        """
        if not self.events:
            return None
        start = min(event.start_time for event in self.events)
        end = max(event.end_time for event in self.events)
        return start, end
    